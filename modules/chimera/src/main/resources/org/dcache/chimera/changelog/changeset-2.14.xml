<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
     http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd">

    <changeSet author="behrmann" id="1" dbms="hsqldb">
        <createProcedure>
            CREATE TRIGGER tgs_insert_acl_dir AFTER INSERT ON t_dirs
              REFERENCING NEW ROW new
              FOR EACH ROW WHEN (new.iname = '..' AND (SELECT itype FROM t_inodes WHERE ipnfsid = new.ipnfsid) = 16384)
                INSERT INTO t_acl
                  SELECT new.ipnfsid, 0, type, BITANDNOT(flags, 8), access_msk, who, who_id, address_msk, ace_order
                  FROM t_acl
                  WHERE rs_id = new.iparent AND BITAND(flags, 3) > 0;
        </createProcedure>
        <createProcedure>
            CREATE TRIGGER tgs_insert_acl_file AFTER INSERT ON t_dirs
              REFERENCING NEW ROW new
              FOR EACH ROW WHEN (new.iname != '..' OR (SELECT itype FROM t_inodes WHERE ipnfsid = new.ipnfsid) != 16384)
                INSERT INTO t_acl
                  SELECT new.ipnfsid, 1, type, BITANDNOT(flags, 11), access_msk, who, who_id, address_msk, ace_order
                  FROM t_acl
                  WHERE rs_id = new.iparent AND BITAND(flags, 1) > 0;
        </createProcedure>
    </changeSet>

    <changeSet id="20.1" author="tigran" dbms="hsqldb">

        <comment>Drop old triggers</comment>

        <sql>
            DROP TRIGGER tgs_insert_acl_dir;
            DROP TRIGGER tgs_insert_acl_file;
        </sql>

        <rollback>
            <createProcedure>
                CREATE TRIGGER tgs_insert_acl_dir AFTER INSERT ON t_dirs
                REFERENCING NEW ROW new
                FOR EACH ROW WHEN (new.iname = '..' AND (SELECT itype FROM t_inodes WHERE ipnfsid = new.ipnfsid) = 16384)
                  INSERT INTO t_acl
                    SELECT new.ipnfsid, 0, type, BITANDNOT(flags, 8), access_msk, who, who_id, address_msk, ace_order
                    FROM t_acl
                    WHERE rs_id = new.iparent AND BITAND(flags, 3) > 0;
            </createProcedure>
            <createProcedure>
                CREATE TRIGGER tgs_insert_acl_file AFTER INSERT ON t_dirs
                REFERENCING NEW ROW new
                FOR EACH ROW WHEN (new.iname != '..' OR (SELECT itype FROM t_inodes WHERE ipnfsid = new.ipnfsid) != 16384)
                  INSERT INTO t_acl
                    SELECT new.ipnfsid, 1, type, BITANDNOT(flags, 11), access_msk, who, who_id, ace_order, address_msk
                    FROM t_acl
                    WHERE rs_id = new.iparent AND BITAND(flags, 1) > 0;
            </createProcedure>
        </rollback>

    </changeSet>

    <changeSet id="21" author="tigran">

        <comment>Remove address mask from ACL</comment>

        <dropColumn tableName="t_acl" columnName="address_msk"/>

        <rollback>
            <addColumn tableName="t_acl">
                <column name="address_msk" type="VARCHAR(32)" defaultValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" remarks="network address mask">
                    <constraints nullable="false"/>
                </column>
            </addColumn>
        </rollback>
    </changeSet>

    <changeSet id="22.1" author="tigran"  dbms="hsqldb">

        <comment>Create new triggers</comment>

        <createProcedure>
            CREATE TRIGGER tgs_insert_acl_dir AFTER INSERT ON t_dirs
            REFERENCING NEW ROW new
            FOR EACH ROW WHEN (new.iname = '..' AND (SELECT itype FROM t_inodes WHERE ipnfsid = new.ipnfsid) = 16384)
              INSERT INTO t_acl
                SELECT new.ipnfsid, 0, type, BITANDNOT(flags, 8), access_msk, who, who_id, ace_order
                FROM t_acl
                WHERE rs_id = new.iparent AND BITAND(flags, 3) > 0;
        </createProcedure>
        <createProcedure>
            CREATE TRIGGER tgs_insert_acl_file AFTER INSERT ON t_dirs
            REFERENCING NEW ROW new
            FOR EACH ROW WHEN (new.iname != '..' OR (SELECT itype FROM t_inodes WHERE ipnfsid = new.ipnfsid) != 16384)
              INSERT INTO t_acl
                SELECT new.ipnfsid, 1, type, BITANDNOT(flags, 11), access_msk, who, who_id, ace_order
                FROM t_acl
                WHERE rs_id = new.iparent AND BITAND(flags, 1) > 0;
        </createProcedure>

        <rollback>
            <sql>
                DROP TRIGGER tgs_insert_acl_dir;
                DROP TRIGGER tgs_insert_acl_file;
            </sql>
        </rollback>
    </changeSet>

    <changeSet author="tigran" id="22.2" dbms="postgresql">
        <createProcedure>
            DROP TRIGGER IF EXISTS tgr_insertACL ON t_dirs;

            CREATE OR REPLACE FUNCTION f_insertACL() RETURNS trigger AS $$
            DECLARE
                msk INTEGER;
                flag INTEGER;
                rstype INTEGER;
                id character varying(36);
                parentid character varying(36);
            BEGIN

                id := NEW.ipnfsid;
                parentid := NEW.iparent;

                SELECT INTO rstype itype FROM t_inodes WHERE ipnfsid = NEW.ipnfsid;

                IF (rstype = 16384 AND NEW.iname = '..') THEN
                    rstype := 0;    -- inserted object is a directory
                    flag := 3;      -- check flags for 'd' and 'f' bits
                    msk := 8;       -- mask contains 'o' bit
                ELSE
                    rstype := 1;    -- inserted object is a file
                    flag := 1;      -- check flags for 'f' bit
                    msk := 11;      -- mask contains 'o','d' and 'f' bits
                END IF;

                INSERT INTO t_acl
                    SELECT id, rstype, type, (flags | msk) # msk, access_msk, who, who_id, ace_order
                        FROM t_acl
                            WHERE  rs_id = parentid AND ((flags &amp; flag) > 0);
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER tgr_insertACL AFTER INSERT ON t_dirs FOR EACH ROW EXECUTE PROCEDURE f_insertACL();
        </createProcedure>
        <rollback>
            <createProcedure>
                DROP TRIGGER IF EXISTS tgr_insertACL ON t_dirs;

                CREATE OR REPLACE FUNCTION f_insertACL() RETURNS trigger AS $$
                DECLARE
                    msk INTEGER;
                    flag INTEGER;
                    rstype INTEGER;
                    id character varying(36);
                    parentid character varying(36);
                BEGIN

                    id := NEW.ipnfsid;
                    parentid := NEW.iparent;

                    SELECT INTO rstype itype FROM t_inodes WHERE ipnfsid = NEW.ipnfsid;

                    IF (rstype = 16384 AND NEW.iname = '..') THEN
                        rstype := 0;    -- inserted object is a directory
                        flag := 3;      -- check flags for 'd' and 'f' bits
                        msk := 8;       -- mask contains 'o' bit
                    ELSE
                        rstype := 1;    -- inserted object is a file
                        flag := 1;      -- check flags for 'f' bit
                        msk := 11;      -- mask contains 'o','d' and 'f' bits
                    END IF;

                    INSERT INTO t_acl
                        SELECT id, rstype, type, (flags | msk) # msk, access_msk, who, who_id, ace_order, address_msk
                            FROM t_acl
                                WHERE  rs_id = parentid AND ((flags &amp; flag) > 0);
                    RETURN NULL;
                END;
                $$ LANGUAGE plpgsql;

                CREATE TRIGGER tgr_insertACL AFTER INSERT ON t_dirs FOR EACH ROW EXECUTE PROCEDURE f_insertACL();
            </createProcedure>
        </rollback>
    </changeSet>

    <changeSet author="tigran" id="23.1" dbms="postgresql">
        <comment>Prepare t_inodes for whole table update</comment>
        <sql>ALTER TABLE t_inodes SET (fillfactor=45)</sql>

        <!-- enforce rewrite -->
        <sql>CLUSTER t_inodes USING t_inodes_pkey</sql>
        <rollback>
            <sql>ALTER TABLE t_inodes SET (fillfactor=75)</sql>
        </rollback>
    </changeSet>

    <changeSet id="23.2" author="tigran">

        <comment>Add access latency/retention policy columns</comment>

        <addColumn tableName="t_inodes">
            <column name="iaccess_latency" type="TINYINT" remarks="file's access latency">
                <constraints nullable="true"/>
            </column>
            <column name="iretention_policy" type="TINYINT" remarks="file's retention policy">
                <constraints nullable="true"/>
            </column>
        </addColumn>

        <sql>
            UPDATE t_inodes SET iaccess_latency = (select iaccesslatency from t_access_latency where t_inodes.ipnfsid = t_access_latency.ipnfsid),
            iretention_policy = (select iretentionpolicy from t_retention_policy where t_inodes.ipnfsid = t_retention_policy.ipnfsid)
            WHERE itype = 32768;
        </sql>

        <dropTable tableName="t_access_latency"/>
        <dropTable tableName="t_retention_policy"/>

        <rollback>

            <comment>how-to downgrade</comment>

            <createTable tableName="t_access_latency">
                <column name="ipnfsid" type="VARCHAR(36)">
                    <constraints nullable="false" primaryKey="true" primaryKeyName="t_access_latency_pkey"/>
                </column>
                <column name="iaccesslatency" type="INT">
                    <constraints nullable="false"/>
                </column>
            </createTable>

            <createTable tableName="t_retention_policy">
                <column name="ipnfsid" type="VARCHAR(36)">
                    <constraints nullable="false" primaryKey="true" primaryKeyName="t_retention_policy_pkey"/>
                </column>
                <column name="iretentionpolicy" type="INT">
                    <constraints nullable="false"/>
                </column>
            </createTable>

            <addForeignKeyConstraint baseColumnNames="ipnfsid" baseTableName="t_access_latency"
                                 constraintName="t_access_latency_ipnfsid_fkey" deferrable="false"
                                 initiallyDeferred="false" onDelete="CASCADE" onUpdate="NO ACTION"
                                 referencedColumnNames="ipnfsid" referencedTableName="t_inodes"
            />

            <addForeignKeyConstraint baseColumnNames="ipnfsid" baseTableName="t_retention_policy"
                                 constraintName="t_retention_policy_ipnfsid_fkey" deferrable="false"
                                 initiallyDeferred="false" onDelete="CASCADE" onUpdate="NO ACTION"
                                 referencedColumnNames="ipnfsid" referencedTableName="t_inodes"
            />

            <sql>
                INSERT INTO t_access_latency SELECT ipnfsid, iaccess_latency FROM t_inodes where iaccess_latency IS NOT NULL;
                INSERT INTO t_retention_policy SELECT ipnfsid, iretention_policy FROM t_inodes where iretention_policy IS NOT NULL;
            </sql>

            <dropColumn tableName="t_inodes" columnName="iaccess_latency"/>
            <dropColumn tableName="t_inodes" columnName="iretention_policy"/>
        </rollback>
    </changeSet>

    <changeSet author="tigran" id="23.3" dbms="postgresql">
        <comment>Prepare t_inodes for whole table update</comment>
        <sql>ALTER TABLE t_inodes SET (fillfactor=75)</sql>
        <rollback />
    </changeSet>

</databaseChangeLog>
