diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/ftp/FeatureList.java cog-jglobus-1.8.0/src/org/globus/ftp/FeatureList.java
--- cog-jglobus-1.8.0.orig/src/org/globus/ftp/FeatureList.java	2006-01-20 21:21:20.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/ftp/FeatureList.java	2010-10-14 10:32:00.529406003 +0200
@@ -15,7 +15,8 @@
  */
 package org.globus.ftp;
 
-import java.util.Vector;
+import java.util.List;
+import java.util.ArrayList;
 import java.util.StringTokenizer;
 
 /**
@@ -32,6 +33,62 @@
 
 public class FeatureList {
 
+    /**
+     * RFC 2389 specified the following syntax for FEAT responce
+     * <pre>
+     * feat-response   = error-response / no-features / feature-listing
+     *  no-features     = "211" SP *TCHAR CRLF
+     *  feature-listing = "211-" *TCHAR CRLF
+     *                    1*( SP feature CRLF )
+     *                    "211 End" CRLF
+     *  feature         = feature-label [ SP feature-parms ]
+     *  feature-label   = 1*VCHAR
+     *  feature-parms   = 1*TCHAR
+     * </pre>
+     *  Feature class represence each individual feature and contain two fields
+     *  required label and optional parms
+     *
+     */
+    public static final class Feature {
+
+        private final String label;
+
+        private final String parms;
+
+        private Feature (String label) {
+
+        this.label = label;
+        this.parms = null;
+
+        }
+
+        private Feature (String label, String parms) {
+
+        this.label = label;
+        this.parms = parms;
+
+        }
+
+        /**
+         * @return the name
+         */
+        public String getLabel() {
+
+        return label;
+
+        }
+
+        /**
+         * @return the qualifiers, null if no qualifiers
+         */
+        public String getParms() {
+
+        return parms;
+
+        }
+    }
+
+    // well known labels
     public static final String SIZE = "SIZE";
     public static final String MDTM = "MDTM";
     public static final String PARALLEL = "PARALLEL";
@@ -41,15 +98,16 @@
     public static final String ABUF = "ABUF";
     public static final String DCAU = "DCAU";
     public static final String PIPE = "PIPE";
+    public static final String MODEX = "MODEX";
+    public static final String GETPUT = "GETPUT";
+    public static final String CKSUM =  "CKSUM";
 
-    protected Vector featVector;
+    protected final List<Feature> features = new ArrayList();
 
     public FeatureList(String featReplyMsg) {
 
-	featVector = new Vector();
-
 	StringTokenizer responseTokenizer
-	    = new StringTokenizer(featReplyMsg, 
+	    = new StringTokenizer(featReplyMsg,
 				  System.getProperty("line.separator"));
 
 	// ignore the first part of the message
@@ -58,18 +116,64 @@
 	}
 
 	while ( responseTokenizer.hasMoreElements() ) {
+
 	    String line = (String) responseTokenizer.nextElement();
 	    line = line.trim().toUpperCase();
-	    if ( !line.startsWith( "211 END" ) ) {
-		featVector.add( line );
-	    }
+	    if ( line.startsWith( "211 END" ) ) {
+            break;
+        }
+        String[] splitFeature = line.split(" ");
+
+        if( splitFeature.length ==2) {
+            features.add(new Feature(splitFeature[0], splitFeature[1]));
+        } else {
+            features.add(new Feature(line));
+        }
+
 	}
     }
 
-    public boolean contains(String feature) {
-	if (feature == null) {
-	    throw new IllegalArgumentException();
+    public boolean contains(String label) {
+
+	if (label == null) {
+	    throw new IllegalArgumentException("feature label is null");
 	}
-	return featVector.contains(feature.toUpperCase());
-    }    
+
+    label = label.toUpperCase();
+
+    for( Feature feature:features ) {
+        if(feature.getLabel().equals(label)) {
+            return true;
+        }
+    }
+
+    return false;
+
+    }
+
+    /**
+     * Get all features that have label equal to the argument
+     * Note that  RFC 2389 does not require a feature with a
+     * given label to appear only once
+     * @param label
+     * @return List of found features with given label in the same order
+     * as they were given to us by the server
+     */
+    public List<Feature> getFeature(String label) {
+
+	if (label == null) {
+	    throw new IllegalArgumentException("feature label is null");
+	}
+
+    label = label.toUpperCase();
+    List<Feature> foundFeatures = new ArrayList();
+    for( Feature feature:features ) {
+        if(feature.getLabel().equals(label)) {
+            foundFeatures.add(feature);
+        }
+    }
+
+    return foundFeatures;
+
+    }
 }
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/ftp/FTPClient.java cog-jglobus-1.8.0/src/org/globus/ftp/FTPClient.java
--- cog-jglobus-1.8.0.orig/src/org/globus/ftp/FTPClient.java	2010-01-04 22:55:46.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/ftp/FTPClient.java	2010-10-14 10:32:00.529406003 +0200
@@ -25,7 +25,12 @@
 import java.util.Date;
 import java.util.StringTokenizer;
 import java.util.Vector;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.TimeZone;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
 import java.text.SimpleDateFormat;
 import java.text.ParseException;
 
@@ -76,6 +81,12 @@
      */
     protected boolean useAllo;
 
+    /**
+     * List of the checksum algorithms supported by the server as described in
+     * {@link http://www.ogf.org/documents/GFD.47.pdf [GridFTP v2 Protocol Description]}
+     */
+    protected List<String> algorithms;
+
     /* for subclasses */
     protected FTPClient() {
     }
@@ -822,26 +833,25 @@
         this.session.transferType = type;
     }
 
-    /**
-     * Sets transfer mode.
-     * @param mode should be {@link Session#MODE_STREAM MODE_STREAM}, 
-     *                       {@link Session#MODE_BLOCK MODE_BLOCK}
-     **/
-    public void setMode(int mode) throws IOException, ServerException {
-        
-        String modeStr = null;
+    protected String getModeStr(int mode)
+    {
         switch (mode) {
         case Session.MODE_STREAM :
-            modeStr = "S";
-            break;
+            return "S";
         case Session.MODE_BLOCK :
-            modeStr = "B";
-            break;
+            return "B";
         default :
             throw new IllegalArgumentException("Bad mode: " + mode);
         }
+    }
         
-        actualSetMode(mode, modeStr);
+    /**
+     * Sets transfer mode.
+     * @param mode should be {@link Session#MODE_STREAM MODE_STREAM},
+     *                       {@link Session#MODE_BLOCK MODE_BLOCK}
+     **/
+    public void setMode(int mode) throws IOException, ServerException {
+        actualSetMode(mode, getModeStr(mode));
     }
 
     protected void actualSetMode(int mode, String modeStr)
@@ -1588,6 +1598,439 @@
         return (this.session.serverMode == Session.SERVER_PASSIVE);
     }
     
+
+    //////////////////////////////////////////////////////////////////////
+    // Implementation of GFD.47 compliant GETPUT support. The reason
+    // why this is implemented in FTPClient rather than GridFTPClient
+    // is, that GFD.47 support is detected via feature strings and is
+    // thus independent of GSI authentication.
+
+
+    /**
+     * Throws ServerException if GFD.47 GETPUT is not supported or
+     * cannot be used.
+     */
+    protected void checkGETPUTSupport()
+        throws ServerException, IOException
+    {
+        if (!isFeatureSupported(FeatureList.GETPUT)) {
+            throw new ServerException(ServerException.UNSUPPORTED_FEATURE);
+        }
+
+        if (controlChannel.isIPv6()) {
+            throw new ServerException(ServerException.UNSUPPORTED_FEATURE,
+                                      "Cannot use GridFTP2 with IP 6");
+        }
+    }
+
+    /**
+     * Regular expression for matching the port information of a
+     * GFD.47 127 reply.
+     */
+    public static final Pattern portPattern =
+        Pattern.compile("\\d+,\\d+,\\d+,\\d+,\\d+,\\d+");
+
+    /**
+     * Reads a GFD.47 compliant 127 reply and extracts the port
+     * information from it.
+     */
+    protected HostPort get127Reply()
+        throws ServerException, IOException, FTPReplyParseException
+    {
+        Reply reply = controlChannel.read();
+
+        if (Reply.isTransientNegativeCompletion(reply)
+            || Reply.isPermanentNegativeCompletion(reply)) {
+            throw new ServerException(ServerException.SERVER_REFUSED,
+                                      reply.getMessage());
+        }
+
+        if (reply.getCode() != 127) {
+            throw new ServerException(ServerException.WRONG_PROTOCOL,
+                                      reply.getMessage());
+        }
+
+        Matcher matcher = portPattern.matcher(reply.getMessage());
+        if (!matcher.find()) {
+            throw new ServerException(ServerException.WRONG_PROTOCOL,
+                                      "Cannot parse 127 reply: "
+                                      + reply.getMessage());
+        }
+
+        return new HostPort(matcher.group());
+    }
+
+    /**
+     * Writes a GFD.47 compliant GET or PUT command to the control
+     * channel.
+     *
+     * @param command Either "GET" or "PUT", depending on the command to issue
+     * @param passive True if the "pasv" parameter should be used
+     * @param port If passive is false, this is the port for
+     *             the "port" parameter
+     * @param mode The value for the "mode" parameter, or 0 if the
+     *             parameter should not be specified
+     * @param path The value for the "path" parameter
+     */
+    private void issueGETPUT(String command,
+                             boolean passive,
+                             HostPort port,
+                             int mode,
+                             String path)
+        throws IOException
+    {
+        Command cmd =
+            new Command(command,
+                        (passive
+                         ? "pasv"
+                         : ("port=" + port.toFtpCmdArgument())
+                         ) + ";" +
+                        "path=" + path + ";" +
+                        (mode > 0
+                         ? "mode=" + getModeStr(mode) + ";"
+                         : ""));
+        controlChannel.write(cmd);
+    }
+
+    /**
+     * Retrieves a file using the GFD.47 (a.k.a GridFTP2) GET command.
+     *
+     * Notice that as a side effect this method may change the local
+     * server facade passive/active mode setting. The caller should
+     * not rely on this setting after call to get2.
+     *
+     * Even though the active/passive status of the current session is
+     * ignored for the actual transfer, it still has to be in a
+     * consistent state prior to calling gridftp2Get.
+     *
+     * @param remoteFileName file to retrieve
+     * @param passive whether to configure the server to be passive
+     * @param sink data sink to store the file
+     * @param mListener marker listener
+     **/
+    public void get2(String remoteFileName,
+                     boolean passive,
+                     DataSink sink,
+                     MarkerListener mListener)
+        throws IOException,
+               ClientException,
+               ServerException
+    {
+        int serverMode = session.serverMode;
+        HostPort serverAddress = session.serverAddress;
+
+        try {
+            // Can we use GETPUT?
+            checkGETPUTSupport();
+
+            // Check sanity of arguments
+            if (session.transferMode == GridFTPSession.MODE_EBLOCK && passive) {
+                throw new IllegalArgumentException("Sender must be active in extended block mode");
+            }
+
+            // All parameters set correctly (or still unset)?
+            Session localSession = localServer.getSession();
+            session.matches(localSession);
+
+            // Connection setup depends a lot on whether we use
+            // passive or active mode. The passive party needs to be
+            // configured before the active party.
+            if (passive) {
+                issueGETPUT("GET", true, null, 0, remoteFileName);
+                session.serverMode = Session.SERVER_PASSIVE;
+                session.serverAddress = get127Reply();
+                setLocalActive();
+                localServer.store(sink);
+            } else {
+                HostPort hp = setLocalPassive();
+                localServer.store(sink);
+                issueGETPUT("GET", false, hp, 0, remoteFileName);
+                session.serverMode = Session.SERVER_ACTIVE;
+            }
+
+            transferRunSingleThread(localServer.getControlChannel(),
+                                    mListener);
+
+        } catch (FTPReplyParseException rpe) {
+            throw ServerException.embedFTPReplyParseException(rpe);
+        } finally {
+            session.serverMode = serverMode;
+            session.serverAddress = serverAddress;
+        }
+    }
+
+
+    /**
+     * Retrieves a file asynchronously using the GFD.47 (a.k.a
+     * GridFTP2) GET command.
+     *
+     * Notice that as a side effect this method may change the local
+     * server facade passive/active mode setting. The caller should
+     * not rely on this setting after call to gridftp2Get.
+     *
+     * Even though the active/passive status of the current session is
+     * ignored for the actual transfer, it still has to be in a
+     * consistent state prior to calling gridftp2Get.
+     *
+     * @param remoteFileName file to retrieve
+     * @param passive whether to configure the server to be passive
+     * @param sink data sink to store the file
+     * @param mListener marker listener
+     **/
+    public TransferState asynchGet2(String remoteFileName,
+                                    boolean passive,
+                                    DataSink sink,
+                                    MarkerListener mListener)
+        throws IOException,
+               ClientException,
+               ServerException
+    {
+        int serverMode = session.serverMode;
+        HostPort serverAddress = session.serverAddress;
+
+        try {
+
+            // Can we use GETPUT?
+            checkGETPUTSupport();
+
+            // Check sanity of arguments
+            if (session.transferMode == GridFTPSession.MODE_EBLOCK && passive) {
+                throw new IllegalArgumentException("Sender must be active in extended block mode");
+            }
+
+            // All parameters set correctly (or still unset)?
+            Session localSession = localServer.getSession();
+            session.matches(localSession);
+
+            // Connection setup depends a lot on whether we use
+            // passive or active mode. The passive party needs to be
+            // configured before the active party.
+            if (passive) {
+                issueGETPUT("GET", true, null, 0, remoteFileName);
+                session.serverMode = Session.SERVER_PASSIVE;
+                session.serverAddress = get127Reply();
+                setLocalActive();
+                localServer.store(sink);
+            } else {
+                HostPort hp = setLocalPassive();
+                localServer.store(sink);
+                issueGETPUT("GET", false, hp, 0, remoteFileName);
+                session.serverMode = Session.SERVER_ACTIVE;
+            }
+
+            return transferStart(localServer.getControlChannel(), mListener);
+
+        } catch (FTPReplyParseException rpe) {
+            throw ServerException.embedFTPReplyParseException(rpe);
+        } finally {
+            // This might not be the most elegant or correct
+            // solution. On the other hand, these parameters do not
+            // seem to be used after transferStart() and it is much
+            // easier to restore the old values now rather than when
+            // the transfer completes.
+            session.serverMode = serverMode;
+            session.serverAddress = serverAddress;
+        }
+    }
+
+    /**
+     * Stores a file at the remote server using the GFD.47 (a.k.a
+     * GridFTP2) PUT command.
+     *
+     * Notice that as a side effect this method may change the local
+     * server facade passive/active mode setting. The caller should
+     * not rely on this setting after call to gridftp2Get.
+     *
+     * Even though the active/passive status of the current session is
+     * ignored for the actual transfer, it still has to be in a
+     * consistent state prior to calling gridftp2Get.
+     *
+     * @param remoteFileName file to retrieve
+     * @param passive whether to configure the server to be passive
+     * @param source data will be read from here
+     * @param mListener marker listener
+     **/
+    public void put2(String remoteFileName,
+                     boolean passive,
+                     DataSource source,
+                     MarkerListener mListener)
+        throws IOException,
+               ClientException,
+               ServerException
+    {
+
+        int serverMode = session.serverMode;
+        HostPort serverAddress = session.serverAddress;
+
+        try {
+            // Can we use GETPUT?
+            checkGETPUTSupport();
+
+            // Check sanity of arguments
+            if (session.transferMode == GridFTPSession.MODE_EBLOCK && !passive) {
+                throw new IllegalArgumentException("Sender must be active in extended block mode");
+            }
+
+            // All parameters set correctly (or still unset)?
+            Session localSession = localServer.getSession();
+            session.matches(localSession);
+
+            // Connection setup depends a lot on whether we use
+            // passive or active mode. The passive party needs to be
+            // configured before the active party.
+            if (passive) {
+                issueGETPUT("PUT", true, null, 0, remoteFileName);
+                session.serverMode = Session.SERVER_PASSIVE;
+                session.serverAddress = get127Reply();
+                setLocalActive();
+                localServer.retrieve(source);
+            } else {
+                HostPort hp = setLocalPassive();
+                localServer.retrieve(source);
+                issueGETPUT("PUT", false, hp, 0, remoteFileName);
+                session.serverMode = Session.SERVER_ACTIVE;
+            }
+
+            transferRunSingleThread(localServer.getControlChannel(),
+                                    mListener);
+
+        } catch (FTPReplyParseException rpe) {
+            throw ServerException.embedFTPReplyParseException(rpe);
+        } finally {
+            session.serverMode = serverMode;
+            session.serverAddress = serverAddress;
+        }
+    }
+
+
+    /**
+     * Stores a file at the remote server using the GFD.47 (a.k.a
+     * GridFTP2) PUT command.
+     *
+     * Notice that as a side effect this method may change the local
+     * server facade passive/active mode setting. The caller should
+     * not rely on this setting after call to gridftp2Get.
+     *
+     * Even though the active/passive status of the current session is
+     * ignored for the actual transfer, it still has to be in a
+     * consistent state prior to calling gridftp2Get.
+     *
+     * @param remoteFileName file to retrieve
+     * @param passive whether to configure the server to be passive
+     * @param source data will be read from here
+     * @param mListener marker listener
+     **/
+    public TransferState asynchPut2(String remoteFileName,
+                                    boolean passive,
+                                    DataSource source,
+                                    MarkerListener mListener)
+        throws IOException,
+               ClientException,
+               ServerException
+    {
+        int serverMode = session.serverMode;
+        HostPort serverAddress = session.serverAddress;
+
+        try {
+
+            // Can we use GETPUT?
+            checkGETPUTSupport();
+
+            // Check sanity of arguments
+            if (session.transferMode == GridFTPSession.MODE_EBLOCK && !passive) {
+                throw new IllegalArgumentException("Sender must be active in extended block mode");
+            }
+
+            // All parameters set correctly (or still unset)?
+            Session localSession = localServer.getSession();
+            session.matches(localSession);
+
+            // Connection setup depends a lot on whether we use
+            // passive or active mode. The passive party needs to be
+            // configured before the active party.
+            if (passive) {
+                issueGETPUT("PUT", true, null, 0, remoteFileName);
+                session.serverMode = Session.SERVER_PASSIVE;
+                session.serverAddress = get127Reply();
+                setLocalActive();
+                localServer.retrieve(source);
+            } else {
+                HostPort hp = setLocalPassive();
+                localServer.retrieve(source);
+                issueGETPUT("PUT", false, hp, 0, remoteFileName);
+                session.serverMode = Session.SERVER_ACTIVE;
+            }
+
+            return transferStart(localServer.getControlChannel(), mListener);
+        } catch (FTPReplyParseException rpe) {
+            throw ServerException.embedFTPReplyParseException(rpe);
+        } finally {
+            // This might not be the most elegant or correct
+            // solution. On the other hand, these parameters do not
+            // seem to be used after transferStart() and it is much
+            // easier to restore the old values now rather than when
+            // the transfer completes.
+            session.serverMode = serverMode;
+            session.serverAddress = serverAddress;
+        }
+    }
+
+    /**
+     * Performs third-party transfer between two servers. If possibly,
+     * GFD.47 (a.k.a GridFTP2) GET and PUT commands are used.
+     *
+     * @param destination   client connected to source server
+     * @param remoteSrcFile source filename
+     * @param destination   client connected to destination server
+     * @param remoteDstFile destination filename
+     * @param mode data channel mode or 0 to use the current mode
+     * @param mListener     marker listener.
+     *                      Can be set to null.
+     */
+    static public void transfer(FTPClient source,
+                                String remoteSrcFile,
+                                FTPClient destination,
+                                String remoteDstFile,
+                                int mode,
+                                MarkerListener mListener)
+        throws IOException, ServerException, ClientException
+    {
+        try {
+            // Although neither mode nor passive setting from in the
+            // session is used, we still perform this check, since
+            // other things may be checked as well.
+            source.session.matches(destination.session);
+
+            HostPort hp;
+            if (destination.isFeatureSupported(FeatureList.GETPUT)) {
+                destination.issueGETPUT("PUT", true, null,
+                                        mode, remoteDstFile);
+                hp = ((GridFTPClient)destination).get127Reply();
+            } else {
+                if (mode > 0) {
+                    destination.setMode(mode);
+                }
+                hp = destination.setPassive();
+                destination.controlChannel.write(new Command("STOR", remoteDstFile));
+            }
+
+            if (source.isFeatureSupported(FeatureList.GETPUT)) {
+                source.issueGETPUT("GET", false, hp, mode, remoteSrcFile);
+            } else {
+                if (mode > 0) {
+                    source.setMode(mode);
+                }
+                source.setActive(hp);
+                source.controlChannel.write(new Command("RETR", remoteSrcFile));
+            }
+
+            source.transferRunSingleThread(destination.controlChannel, mListener);
+        } catch (FTPReplyParseException rpe) {
+            throw ServerException.embedFTPReplyParseException(rpe);
+        }
+    }
+
+
     public boolean isActiveMode() {
         return (this.session.serverMode == Session.SERVER_ACTIVE);
     }
@@ -1613,5 +2056,179 @@
     public boolean getUseAllo() {
         return this.useAllo;
     }
-    
+
+
+    /**
+     *  According to
+     * {@link http://www.ogf.org/documents/GFD.47.pdf [GridFTP v2 Protocol Description]}
+     * checksum feature has the following syntax:
+     * <pre>
+     * CKSUM <algorithm>[, …]
+     * </pre>
+     * getSupportedCksumAlgorithms parses checsum feauture parms and form a
+     * list of checksum algorithms supported by the server
+     * @return a list of checksum algorithms supported by the server in the order
+     * specified by the server
+     * @throws org.globus.ftp.exception.ClientException
+     * @throws org.globus.ftp.exception.ServerException
+     * @throws java.io.IOException
+     */
+    public List<String> getSupportedCksumAlgorithms()
+            throws ClientException, ServerException, IOException {
+
+        if(algorithms != null) {
+            return algorithms;
+        }
+
+        // check if the CKSUM algorithm is supported by the server
+        List<FeatureList.Feature> cksumFeature =
+                getFeatureList().getFeature(FeatureList.CKSUM);
+        if(cksumFeature == null) {
+            algorithms = Collections.emptyList();
+            return algorithms;
+        }
+
+        algorithms = new ArrayList();
+        for(FeatureList.Feature feature:cksumFeature) {
+            String[] parms = feature.getParms().split(",");
+            for (String parm: parms) {
+                algorithms.add(parm);
+            }
+        }
+        return algorithms;
+    }
+
+    public boolean isCksumAlgorithmSupported(String algorithm)
+            throws ClientException, ServerException, IOException {
+        return getSupportedCksumAlgorithms().contains(algorithm.toUpperCase());
+    }
+
+    private void checkCksumSupport(String algorithm)
+            throws ClientException, ServerException, IOException {
+
+        // check if the CKSUM is supported by the server
+        if (! isFeatureSupported(FeatureList.CKSUM) ) {
+            throw new ClientException(
+                                ClientException.OTHER,
+                                FeatureList.CKSUM+" is not supported by server");
+        }
+
+        // check if the CKSUM algorithm is supported by the server
+        if(! isCksumAlgorithmSupported(algorithm) ) {
+            throw new ClientException(
+                                ClientException.OTHER,
+                                FeatureList.CKSUM+" algorithm "+algorithm+
+                                " is not supported by server");
+        }
+
+    }
+
+    /**
+     * implement GridFTP v2 CKSM command from
+     * {@link http://www.ogf.org/documents/GFD.47.pdf [GridFTP v2 Protocol Description]}
+     * <pre>
+     * 5.1 CKSM
+     * This command is used by the client to request checksum calculation over a portion or
+     * whole file existing on the server. The syntax is:
+     * CKSM <algorithm> <offset> <length> <path> CRLF
+     * Server executes this command by calculating specified type of checksum over
+     * portion of the file starting at the offset and of the specified length. If length is –1,
+     * the checksum will be calculated through the end of the file. On success, the server
+     * replies with
+     * 2xx <checksum value>
+     * Actual format of checksum value depends on the algorithm used, but generally,
+     * hexadecimal representation should be used.
+     * </pre>
+     *
+     * @param algorithm ckeckum alorithm
+     * @param offset
+     * @param length
+     * @param path
+     * @return ckecksum value returned by the server
+     * @throws org.globus.ftp.exception.ClientException
+     * @throws org.globus.ftp.exception.ServerException
+     * @throws java.io.IOException
+     */
+    public String getChecksum(String algorithm,
+                              long offset,
+                              long length,
+                              String path)
+    throws ClientException, ServerException, IOException {
+
+        // check if we the cksum commands and specific algorithm are supported
+        checkCksumSupport(algorithm);
+
+        // form CKSM command
+        String parameters = String.format("%s %d %d %s",algorithm, offset,length,path);
+        Command cmd = new Command("CKSM", parameters);
+
+        // transfer command, obtain reply
+        Reply cksumReply = doCommand(cmd);
+
+        // check for error
+        if( !Reply.isPositiveCompletion(cksumReply) ) {
+            throw new ServerException(ServerException.SERVER_REFUSED,
+                    cksumReply.getMessage());
+        }
+
+        return cksumReply.getMessage();
+    }
+
+    /**
+     * GridFTP v2 CKSM command for the whole file
+     * @param  algorithm ckeckum alorithm
+     * @param  path
+     * @return ckecksum value returned by the server
+     * @throws org.globus.ftp.exception.ClientException
+     * @throws org.globus.ftp.exception.ServerException
+     * @throws java.io.IOException
+     */
+    public String getChecksum(String algorithm,
+                              String path)
+    throws ClientException, ServerException, IOException {
+        return getChecksum(algorithm,0,-1,path);
+    }
+
+    /**
+     * implement GridFTP v2 SCKS command as described in
+     * {@link http://www.ogf.org/documents/GFD.47.pdf [GridFTP v2 Protocol Description]}
+     * <pre>
+     * 5.2 SCKS
+     * This command is sent prior to upload command such as STOR, ESTO, PUT. It is used
+     * to convey to the server that the checksum value for the file which is about to be
+     * uploaded. At the end of transfer, server will calculate checksum for the received file,
+     * and if it does not match, will consider the transfer to have failed. Syntax of the
+     * command is:
+     * SCKS <algorithm> <value> CRLF
+     * Actual format of checksum value depends on the algorithm used, but generally,
+     * hexadecimal representation should be used.
+     * </pre>
+     * @param algorithm
+     * @param value
+     * @throws org.globus.ftp.exception.ClientException
+     * @throws org.globus.ftp.exception.ServerException
+     * @throws java.io.IOException
+     */
+    public void setChecksum(String algorithm, String value)
+    throws ClientException, ServerException, IOException {
+
+        // check if we the cksum commands and specific algorithm are supported
+        checkCksumSupport(algorithm);
+
+        // form CKSM command
+        String parameters = String.format("%s %s",algorithm, value);
+        Command cmd = new Command("SCKS", parameters);
+
+        // transfer command, obtain reply
+        Reply cksumReply = doCommand(cmd);
+
+        // check for error
+        if( !Reply.isPositiveCompletion(cksumReply) ) {
+            throw new ServerException(ServerException.SERVER_REFUSED,
+                    cksumReply.getMessage());
+        }
+
+        return;
+    }
+
 } //FTPClient
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/ftp/GridFTPClient.java cog-jglobus-1.8.0/src/org/globus/ftp/GridFTPClient.java
--- cog-jglobus-1.8.0.orig/src/org/globus/ftp/GridFTPClient.java	2008-10-29 21:00:59.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/ftp/GridFTPClient.java	2010-10-14 10:31:50.339406000 +0200
@@ -27,6 +27,8 @@
 import org.globus.ftp.exception.UnexpectedReplyCodeException;
 import org.globus.ftp.vanilla.Command;
 import org.globus.ftp.vanilla.Reply;
+import org.globus.ftp.vanilla.TransferState;
+import org.globus.ftp.vanilla.FTPControlChannel;
 import org.globus.ftp.extended.GridFTPServerFacade;
 import org.globus.ftp.extended.GridFTPControlChannel;
 import org.globus.gsi.gssapi.auth.Authorization;
@@ -213,30 +215,18 @@
 	}
     }
 
-    /**
-     * Sets transfer mode.
-     * @param mode should be {@link Session#MODE_STREAM MODE_STREAM}, 
-     *                       {@link Session#MODE_BLOCK MODE_BLOCK}, or 
-     *                       {@link GridFTPSession#MODE_EBLOCK MODE_EBLOCK}
-     **/
-    public void setMode(int mode) 
-        throws IOException, ServerException { 
-        String modeStr = null;
+    protected String getModeStr(int mode)
+    {
         switch (mode) {
         case Session.MODE_STREAM: 
-            modeStr = "S"; 
-            break;
+            return "S";
         case Session.MODE_BLOCK: 
-            modeStr = "B";
-            break;
+            return "B";
         case GridFTPSession.MODE_EBLOCK: 
-            modeStr = "E";
-            break;
+            return "E";
         default: 
             throw new IllegalArgumentException("Bad mode: " + mode); 
         }
-        
-        actualSetMode(mode, modeStr);
     }
 
     /**
@@ -1016,5 +1006,4 @@
             throw ServerException.embedFTPReplyParseException(rpe);
         }
     }
-    
 }
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/io/streams/FTPInputStream.java cog-jglobus-1.8.0/src/org/globus/io/streams/FTPInputStream.java
--- cog-jglobus-1.8.0.orig/src/org/globus/io/streams/FTPInputStream.java	2006-01-20 21:21:29.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/io/streams/FTPInputStream.java	2010-10-14 10:31:50.339406000 +0200
@@ -21,6 +21,7 @@
 import org.globus.ftp.FTPClient;
 import org.globus.ftp.Session;
 import org.globus.ftp.InputStreamDataSink;
+import org.globus.ftp.FeatureList;
 import org.globus.ftp.vanilla.TransferState;
 import org.globus.ftp.exception.FTPException;
 import org.globus.common.ChainedIOException;
@@ -30,6 +31,7 @@
     protected InputStream input;
     protected FTPClient ftp;
     protected TransferState state;
+    protected boolean useGFD47;
 
     protected FTPInputStream() {
     }
@@ -52,8 +54,22 @@
 			  boolean passive,
 			  int type) 
 	throws IOException, FTPException {
+        this(host, port, user, pwd, file, passive, type, true);
+    }
+
+    public FTPInputStream(String host,
+                        int port,
+                        String user,
+                        String pwd,
+                        String file,
+                        boolean passive,
+                        int type,
+                          boolean useGFD47)
+      throws IOException, FTPException {
 	this.ftp = new FTPClient(host, port);
 	this.ftp.authorize(user, pwd);
+        this.useGFD47 =
+            (useGFD47 && this.ftp.isFeatureSupported(FeatureList.GETPUT));
 	get(passive, type, file);
     }
     
@@ -67,6 +83,16 @@
 	try {
 	    this.ftp.setType(type);
 
+          sink = new InputStreamDataSink();
+          this.input = sink.getInputStream();
+
+            if (useGFD47) {
+                this.state =
+                    this.ftp.asynchGet2(remoteFile,
+                                        passive,
+                                        sink,
+                                        null);
+            } else {
 	    if (passive) {
 		this.ftp.setPassive();
 		this.ftp.setLocalActive();
@@ -75,13 +101,10 @@
 		this.ftp.setActive();
 	    }
 	    
-	    sink = new InputStreamDataSink();
-
-	    this.input = sink.getInputStream();
-
 	    this.state = this.ftp.asynchGet(remoteFile,
 					    sink,
 					    null);
+            }
 	
 	    this.state.waitForStart();
 
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/io/streams/FTPOutputStream.java cog-jglobus-1.8.0/src/org/globus/io/streams/FTPOutputStream.java
--- cog-jglobus-1.8.0.orig/src/org/globus/io/streams/FTPOutputStream.java	2006-01-20 21:21:29.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/io/streams/FTPOutputStream.java	2010-10-14 10:31:50.339406000 +0200
@@ -21,6 +21,7 @@
 import org.globus.ftp.FTPClient;
 import org.globus.ftp.Session;
 import org.globus.ftp.OutputStreamDataSource;
+import org.globus.ftp.FeatureList;
 import org.globus.ftp.vanilla.TransferState;
 import org.globus.ftp.exception.FTPException;
 import org.globus.common.ChainedIOException;
@@ -30,6 +31,7 @@
     protected OutputStream output;
     protected FTPClient ftp;
     protected TransferState state;
+    protected boolean useGFD47;
 
     protected FTPOutputStream() {
     }
@@ -54,8 +56,23 @@
 			   boolean passive,
 			   int type) 
 	throws IOException, FTPException {
+        this(host, port, user, pwd, file, append, passive, type, true);
+    }
+
+    public FTPOutputStream(String host,
+                         int port,
+                         String user,
+                         String pwd,
+                         String file,
+                         boolean append,
+                         boolean passive,
+                         int type,
+                           boolean useGFD47)
+      throws IOException, FTPException {
 	this.ftp = new FTPClient(host, port);
 	this.ftp.authorize(user, pwd);
+        this.useGFD47 =
+            (useGFD47 && this.ftp.isFeatureSupported(FeatureList.GETPUT));
 	put(passive, type, file, append);
     }
 
@@ -107,6 +124,15 @@
 	try {
 	    this.ftp.setType(type);
 
+          source = new OutputStreamDataSource(2048);
+
+            if (useGFD47) {
+                this.state =
+                    this.ftp.asynchPut2(remoteFile,
+                                        passive,
+                                        source,
+                                        null);
+            } else {
 	    if (passive) {
 		this.ftp.setPassive();
 		this.ftp.setLocalActive();
@@ -114,13 +140,11 @@
 		this.ftp.setLocalPassive();
 		this.ftp.setActive();
 	    }
-	    
-	    source = new OutputStreamDataSource(2048);
-	    
 	    this.state = this.ftp.asynchPut(remoteFile,
 					    source,
 					    null,
 					    append);
+            }
 	    
 	    this.state.waitForStart();
 
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/io/streams/GridFTPInputStream.java cog-jglobus-1.8.0/src/org/globus/io/streams/GridFTPInputStream.java
--- cog-jglobus-1.8.0.orig/src/org/globus/io/streams/GridFTPInputStream.java	2006-01-20 21:21:29.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/io/streams/GridFTPInputStream.java	2010-10-14 10:31:50.339406000 +0200
@@ -20,6 +20,7 @@
 import org.globus.ftp.GridFTPClient;
 import org.globus.ftp.Session;
 import org.globus.ftp.DataChannelAuthentication;
+import org.globus.ftp.FeatureList;
 import org.globus.ftp.exception.FTPException;
 import org.globus.gsi.gssapi.auth.Authorization;
 import org.globus.gsi.gssapi.auth.HostAuthorization;
@@ -28,6 +29,7 @@
 
 public class GridFTPInputStream extends FTPInputStream {
 
+
     public GridFTPInputStream(GSSCredential cred,
 			      String host, 
 			      int port, 
@@ -35,7 +37,7 @@
 	throws IOException, FTPException {
 	this(cred, HostAuthorization.getInstance(),
 	     host, port, 
-	     file, true, Session.TYPE_IMAGE, true);
+           file, true, Session.TYPE_IMAGE, true, true);
     }
 
     public GridFTPInputStream(GSSCredential cred,
@@ -46,7 +48,19 @@
 			      boolean reqDCAU) 
 	throws IOException, FTPException {
 	this(cred, auth, host, port, 
-	     file, true, Session.TYPE_IMAGE, reqDCAU);
+           file, true, Session.TYPE_IMAGE, reqDCAU, true);
+    }
+
+    public GridFTPInputStream(GSSCredential cred,
+                            Authorization auth,
+                            String host,
+                            int port,
+                            String file,
+                            boolean reqDCAU,
+                              boolean useGFD47)
+      throws IOException, FTPException {
+      this(cred, auth, host, port,
+           file, true, Session.TYPE_IMAGE, reqDCAU, useGFD47);
     }
 
     public GridFTPInputStream(GSSCredential cred,
@@ -56,12 +70,16 @@
 			      String file,
 			      boolean passive,
 			      int type,
-			      boolean reqDCAU) 
+                            boolean reqDCAU,
+                              boolean useGFD47)
 	throws IOException, FTPException {
 	GridFTPClient gridFtp = new GridFTPClient(host, port);
 	gridFtp.setAuthorization(auth);
 	gridFtp.authenticate(cred);
 	
+        this.useGFD47 =
+            (useGFD47 && gridFtp.isFeatureSupported(FeatureList.GETPUT));
+
 	if (gridFtp.isFeatureSupported("DCAU")) {
 	    if (!reqDCAU) {
 		gridFtp.setDataChannelAuthentication(DataChannelAuthentication.NONE);
@@ -74,5 +92,4 @@
 	
 	get(passive, type, file);
     }
-
 }
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/io/streams/GridFTPOutputStream.java cog-jglobus-1.8.0/src/org/globus/io/streams/GridFTPOutputStream.java
--- cog-jglobus-1.8.0.orig/src/org/globus/io/streams/GridFTPOutputStream.java	2007-11-26 17:33:13.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/io/streams/GridFTPOutputStream.java	2010-10-14 10:31:50.339406000 +0200
@@ -20,6 +20,7 @@
 import org.globus.ftp.GridFTPClient;
 import org.globus.ftp.Session;
 import org.globus.ftp.DataChannelAuthentication;
+import org.globus.ftp.FeatureList;
 import org.globus.ftp.exception.FTPException;
 import org.globus.gsi.gssapi.auth.Authorization;
 import org.globus.gsi.gssapi.auth.HostAuthorization;
@@ -62,8 +63,22 @@
                    long size)
     throws IOException, FTPException {
     this(cred, auth, 
+         host, port, file, append, reqDCAU, true, size);
+    }
+
+    public GridFTPOutputStream(GSSCredential cred,
+                   Authorization auth,
+                   String host,
+                   int port,
+                   String file,
+                   boolean append,
+                   boolean reqDCAU,
+                   boolean gridftp2,
+                   long size)
+    throws IOException, FTPException {
+    this(cred, auth,
          host, port, file, append,
-         true, Session.TYPE_IMAGE, reqDCAU, size);
+         true, Session.TYPE_IMAGE, reqDCAU, gridftp2, size);
     }
     
     public GridFTPOutputStream(GSSCredential cred, 
@@ -78,7 +93,7 @@
     throws IOException, FTPException {
         this(cred, auth, 
              host, port, file, append, 
-             passive, type, reqDCAU, -1);
+             passive, type, reqDCAU, true, -1);
     }
 
     public GridFTPOutputStream(GSSCredential cred, 
@@ -90,12 +105,16 @@
 			       boolean passive,
 			       int type,
 			       boolean reqDCAU,
+                               boolean useGFD47,
 			       long size)
 	throws IOException, FTPException {
 	GridFTPClient gridFtp = new GridFTPClient(host, port);
 	gridFtp.setAuthorization(auth);
 	gridFtp.authenticate(cred);
 	
+        this.useGFD47 =
+            (useGFD47 && gridFtp.isFeatureSupported(FeatureList.GETPUT));
+
 	if (gridFtp.isFeatureSupported("DCAU")) {
 	    if (!reqDCAU) {
 		gridFtp.setDataChannelAuthentication(DataChannelAuthentication.NONE);
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/io/urlcopy/UrlCopy.java cog-jglobus-1.8.0/src/org/globus/io/urlcopy/UrlCopy.java
--- cog-jglobus-1.8.0.orig/src/org/globus/io/urlcopy/UrlCopy.java	2007-11-26 17:33:22.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/io/urlcopy/UrlCopy.java	2010-10-14 10:31:50.339406000 +0200
@@ -76,6 +76,7 @@
     protected GlobusURL dstUrl         = null;
     protected boolean canceled         = false;
     protected boolean thirdParty       = true;
+    protected boolean gridftp2         = true;
     protected List listeners           = null;
     
     protected long sourceOffset      = 0;
@@ -414,6 +415,26 @@
     
 
     /**
+     * Enables/disables usage of GridFTP2 (as specified in GFD.47) if
+     * supported by the server.
+     *
+     * @param gridftp2 if true enable, false disable
+     */
+    public void setGridFTP2(boolean gridftp2) {
+        this.gridftp2 = gridftp2;
+    }
+
+    /**
+     * Returns whether GridFTP2 (as specified in GFD.47) is to be used
+     * when supported by the server.
+     *
+     * @return true if enabled, false if disabled
+     */
+    public boolean getGridFTP2() {
+        return gridftp2;
+    }
+
+    /**
      * Cancels the transfer in progress. If no transfer
      * is in progress it is ignored.
      */
@@ -560,7 +581,8 @@
                                         srcUrl.getHost(),
                                         srcUrl.getPort(),
                                         fromFile,
-                                        getDCAU());
+                                        getDCAU(),
+                                        getGridFTP2());
             
         } else if (fromP.equalsIgnoreCase("https")) {
             Authorization auth = getSourceAuthorization();
@@ -619,6 +641,7 @@
                                           toFile,
                                           appendMode,
                                           getDCAU(),
+                                          getGridFTP2(),
                                           (disableAllo ? -1 : size));
         } else if (toP.equalsIgnoreCase("https")) {
             Authorization auth = getDestinationAuthorization();
@@ -733,6 +756,12 @@
                 this.destinationOffset == 0 && 
                 this.sourceLength == Long.MAX_VALUE) {
                 
+                if (gridftp2) {
+                    FTPClient.transfer(srcFTP, srcUrl.getPath(),
+                                       dstFTP, dstUrl.getPath(),
+                                       GridFTPSession.MODE_STREAM,
+                                       null);
+                } else {
                 srcFTP.setMode(Session.MODE_STREAM);
                 dstFTP.setMode(Session.MODE_STREAM);
                    
@@ -741,6 +770,7 @@
                                 dstUrl.getPath(), 
                                 false, 
                                 null);
+                }
             } else if (srcFTP instanceof GridFTPClient && 
                        dstFTP instanceof GridFTPClient) {
                 
diff -Naur cog-jglobus-1.8.0.orig/src/org/globus/tools/GlobusUrlCopy.java cog-jglobus-1.8.0/src/org/globus/tools/GlobusUrlCopy.java
--- cog-jglobus-1.8.0.orig/src/org/globus/tools/GlobusUrlCopy.java	2007-11-26 17:36:31.000000000 +0100
+++ cog-jglobus-1.8.0/src/org/globus/tools/GlobusUrlCopy.java	2010-10-14 10:31:50.349406000 +0200
@@ -41,6 +41,8 @@
         "\t-nodcau | -no-data-channel-authentication\n" +
         "\t      Turn off data channel authentication for ftp transfers\n" +
         "\t      Applies to FTP protocols only.\n" + 
+        "\t-nogridftp2 | -no-gridftp2\n" +
+        "\t      Turn use of GridFTP2 off (on by default)\n" +
         "\t-tcp-bs <size> | -tcp-buffer-size <size>\n" +
         "\t      Specifies the size (in bytes) of the TCP buffer to be\n" +
         "\t      used by the underlying FTP data channels.\n" +
@@ -63,6 +65,7 @@
 
         boolean thirdPartyTransfer = true;
         boolean dcau = true;
+        boolean gridftp2 = true;
         boolean disableAllo = false;
         int tcpBufferSize = 0;
         
@@ -76,6 +79,9 @@
             } else if (args[i].equalsIgnoreCase("-nodcau") ||
                        args[i].equalsIgnoreCase("-no-data-channel-authentication")) {
                 dcau = false;
+            } else if (args[i].equalsIgnoreCase("-nogridftp2") ||
+                       args[i].equalsIgnoreCase("-no-gridftp2")) {
+                gridftp2 = false;
             } else if (args[i].equalsIgnoreCase("-debug")) {
                 debug = true;
             } else if (args[i].equalsIgnoreCase("-ss")) {
@@ -170,6 +176,7 @@
             uc.setDestinationUrl(to);
             uc.setUseThirdPartyCopy(thirdPartyTransfer);
             uc.setDCAU(dcau);
+            uc.setGridFTP2(gridftp2);
             uc.setSourceAuthorization(srcAuth);
             uc.setDestinationAuthorization(dstAuth);
             uc.setDisableAllo(disableAllo);
