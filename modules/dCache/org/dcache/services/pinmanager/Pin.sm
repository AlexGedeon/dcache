%{
// Pinner task for the pin manager
%}


%class Pin
%package org.dcache.services.pinmanager
%access package
%import diskCacheV111.vehicles.PinManagerPinMessage
%import diskCacheV111.vehicles.PinManagerUnpinMessage
%import diskCacheV111.vehicles.PinManagerExtendLifetimeMessage
%import dmg.cells.nucleus.CellMessage


%start PinFSM::Unknown
%map PinFSM
%%

/* Since pins may be recovered from the database, we initially
 * have no knowledge about whether the file is pinned or unpinned.
 * We therefore have this initial state. During recovery from the 
 * database, requests are added via the special recover(request) 
 * event.
 */
Unknown
{
        recover(request: PinRequest)
                Pinned
                {
                        add(request);
                }
        messageArrived(envelope: CellMessage, message: PinManagerPinMessage)
                Pinning
                {
                        add(ctxt.createRequest(envelope, message));
                }
        adminPin(lifetime: long)
                Pinning
                {
                        add(ctxt.createRequest(lifetime, 0,"localhost"));
                }
        adminUnpin(pinId: long)
                Dead
                {
                }
        messageArrived(envelope: CellMessage, message: PinManagerUnpinMessage)
                Dead
                {
                        returnFailure(envelope, 1, "Pin not found");
                }
        messageArrived(envelope: CellMessage, message: PinManagerExtendLifetimeMessage)
                Dead
                {
                        returnFailure(envelope, 1, "Pin not found");
                }
}

/* The file is in the process of being pinned. The pinning operation
 * is performed outside this state machine and we are informed about
 * the result via either a pinSucceeded() or pinFailed() event.
 */
Pinning
Entry
{
        startPinner();
}
{
        pinSucceeded() [ ctxt.isEmpty() ]
                Unpinning
                {
                }
        pinSucceeded() 
                Pinned
                {
                        confirmAll();
                }
        pinFailed()
                Dead
                {
                        removeAll();
                }
}

/* The file is pinned.
 */
Pinned
{
        messageArrived(envelope: CellMessage, message: PinManagerPinMessage)
                nil
                {
                        confirm(ctxt.add(ctxt.createRequest(envelope, message)));
                }
        messageArrived(envelope: CellMessage, message: PinManagerUnpinMessage)
                        [ ctxt.isLast(ctxt.getRequest(message)) ]
                Unpinning
                {
                        remove(ctxt.getRequest(message));
                        returnSuccess(envelope);
                }
        adminUnpin(pinId: long)
                        [ ctxt.isLast(ctxt.getRequest(pinId)) ]
                Unpinning
                {
                        remove(ctxt.getRequest(pinId));
                }
        timeout(request: PinRequest) 
                        [ ctxt.isLast(request) ]
                Unpinning
                {
                        remove(request);
                }
}

/* The file is in the process of being unpinned. The operation
 * is performed outside this state machine and we are informed about
 * the result via either a unpinSucceeded() or unpinFailed() event.
 */
Unpinning
Entry
{
        startUnpinner();
}
{
        unpinSucceeded() [ !ctxt.isEmpty() ]
                Pinning
                {
                }
        unpinSucceeded()
                Dead
                {
                }
        unpinFailed() [ !ctxt.isEmpty() ]
                Pinning
                {
                }
        unpinFailed()
                Dead
                {
                }
}

/* The pin has been unregistered from the pin manager. This is 
 * an end state and the pin cannot be used anymore.
 */
Dead
Entry
{
        unregister();
}
{
        Default
                nil
                {
                }
}

Default
{
        recover(request: PinRequest)
                nil
                {
                        add(request);
                }
        messageArrived(envelope: CellMessage, message: PinManagerPinMessage)
                nil
                {
                        add(ctxt.createRequest(envelope, message));
                }
        adminPin(lifetime: long)
                nil
                {
                        add(ctxt.createRequest(lifetime, 0,"localhost"));
                }
        messageArrived(envelope: CellMessage, message: PinManagerUnpinMessage) 
                        [ ctxt.getRequest(message) != null ]
                nil
                {
                        remove(ctxt.getRequest(message));
                        returnSuccess(envelope);
                }
        messageArrived(envelope: CellMessage, message: PinManagerUnpinMessage) 
                nil
                {
                        returnFailure(envelope, 1, "Pin not found");
                }
        adminUnpin(pinId: long)
                        [ ctxt.getRequest(pinId) != null]
                nil
                {
                        remove(ctxt.getRequest(pinId));
                }
        adminUnpin(request: PinRequest)
                nil
                {
                }
        messageArrived(envelope: CellMessage, message: PinManagerExtendLifetimeMessage) 
                        [ ctxt.getRequest(message) != null ]
                nil
                {
                        extendLifetime(ctxt.getRequest(message), message.getNewLifetime());
                        returnSuccess(envelope);
                }
        messageArrived(envelope: CellMessage, message: PinManagerExtendLifetimeMessage) 
                nil
                {
                        returnFailure(envelope, 1, "Pin not found");
                }        
        timeout(request: PinRequest)
                nil
                {
                        remove(request);
                }
}


%%
