package org.dcache.gplazma.plugins;

import java.io.IOException;
import java.security.Principal;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.globus.gsi.jaas.GlobusPrincipal;
import org.dcache.auth.FQANPrincipal;
import org.dcache.auth.GidPrincipal;
import org.dcache.auth.UidPrincipal;
import org.dcache.auth.GroupNamePrincipal;
import org.dcache.auth.UserNamePrincipal;
import org.dcache.auth.LoginNamePrincipal;
import org.dcache.auth.LoginUidPrincipal;
import org.dcache.auth.LoginGidPrincipal;
import org.dcache.gplazma.AuthenticationException;
import org.dcache.gplazma.SessionID;
import org.dcache.gplazma.SessionAttribute;
import org.dcache.gplazma.HomeDirectory;
import org.dcache.gplazma.RootDirectory;
import org.dcache.gplazma.ReadOnly;
import org.dcache.gplazma.plugins.AuthzMapLineParser.UserAuthzInformation;
import gplazma.authz.util.NameRolePair;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Sets;
import com.google.common.base.Objects;
import com.google.common.primitives.Longs;
import static com.google.common.collect.Iterables.*;
import static com.google.common.base.Predicates.*;

/**
 * Plugin uses AuthzDB for mapping group to UID, GIDs and a user name.
 *
 * Group names are typically generated by mapping FQANs and DNs in
 * another plugin and there will be a primary group name.
 *
 * LoginNamePrincipal, LoginUidPrincipal, and LoginGidPrincipal are
 * used to pick one among multiple possible UIDs and and to pick a
 * primary group.
 */
public class AuthzDbPlugin
    implements GPlazmaMappingPlugin, GPlazmaSessionPlugin
{
    private static final Logger _log =
        LoggerFactory.getLogger(AuthzDbPlugin.class);

    private static final long REFRESH_PERIOD =
        TimeUnit.SECONDS.toMillis(10);

    private static final String AUTHZDB_DEFAULT =
        "/etc/grid-security/storage-authzdb";
    private static final String AUTHZDB = "authzdb";

    private final SourceBackedPredicateMap<String,UserAuthzInformation> _map;

    public AuthzDbPlugin(String[] args) throws IOException
    {
        Map<String,String> kvmap =
            ArgumentMapFactory.createFromKeyValuePairs(args);
        String path =
            ArgumentMapFactory.getValue(kvmap, AUTHZDB, AUTHZDB_DEFAULT);
        _map = new SourceBackedPredicateMap<String,UserAuthzInformation>(new FileLineSource(path, REFRESH_PERIOD), new AuthzMapLineParser());
    }

    /**
     * package visible constructor for testing purposes
     * @param authzMapCache map of usernames to user information (e.q. uid/gid)
     */
    AuthzDbPlugin(SourceBackedPredicateMap<String,UserAuthzInformation> map)
    {
        _map = map;
    }

    private long getUniqueUidFor(String name)
        throws AuthenticationException
    {
        Collection<UserAuthzInformation> mappings =
            _map.getValuesForPredicatesMatching(name);
        if (mappings.isEmpty()) {
            throw new AuthenticationException("No mapping exists for " + name);
        }
        long uid = getFirst(mappings, null).getUid();
        for (UserAuthzInformation mapping: mappings) {
            if (mapping.getUid() != uid) {
                throw new AuthenticationException("No unique mapping exists for " + name);
            }
        }
        return uid;
    }

    private long getUniquePrimaryGidFor(String name)
        throws AuthenticationException
    {
        Collection<UserAuthzInformation> mappings =
            _map.getValuesForPredicatesMatching(name);
        if (mappings.isEmpty()) {
            throw new AuthenticationException("No mapping exists for " + name);
        }
        long gid = getFirst(mappings, null).getGids()[0];
        for (UserAuthzInformation mapping: mappings) {
            if (mapping.getGids()[0] != gid) {
                throw new AuthenticationException("No unique mapping exists for " + name);
            }
        }
        return gid;
    }

    @Override
    public void map(SessionID sID,
                    Set<Principal> principals,
                    Set<Principal> authorizedPrincipals)
        throws AuthenticationException
    {
        /* Classify input principals.
         */
        Collection<String> groupNames = Sets.newHashSet();
        String loginName = null;
        Long loginUid = null;
        Long loginGid = null;
        String primaryGroup = null;
        for (Principal principal: principals) {
            if (principal instanceof LoginNamePrincipal) {
                if (loginName != null) {
                    throw new AuthenticationException("Duplicate login names");
                }
                loginName = principal.getName();
            } else if (principal instanceof LoginUidPrincipal) {
                if (loginUid != null) {
                    throw new AuthenticationException("Duplicate login UIDs");
                }
                loginUid = ((LoginUidPrincipal) principal).getUid();
            } else if (principal instanceof LoginGidPrincipal) {
                if (loginGid != null) {
                    throw new AuthenticationException("Duplicate login GIDs");
                }
                loginGid =((LoginGidPrincipal) principal).getGid();
            } else if (principal instanceof GroupNamePrincipal) {
                if (((GroupNamePrincipal) principal).isPrimaryGroup()) {
                    if (primaryGroup != null) {
                        throw new AuthenticationException("Ambiguous primary group");
                    }
                    primaryGroup = principal.getName();
                }
                groupNames.add(principal.getName());
            }
        }

        /* Determine the UIDs and GIDs available to the user
         */
        Collection<Long> uids = Sets.newHashSet();
        Collection<Long> gids = Sets.newHashSet();
        for (String groupName: groupNames) {
            Collection<UserAuthzInformation> mappings =
                _map.getValuesForPredicatesMatching(groupName);
            for (UserAuthzInformation mapping: mappings) {
                uids.add(mapping.getUid());
                gids.addAll(Longs.asList(mapping.getGids()));
            }
        }

        /* Verify that the login name, login UID and login GID are
         * among the valid values.
         */
        if (loginName != null && !groupNames.contains(loginName)) {
            throw new AuthenticationException("Not authorized to use login name: " + loginName);
        }
        if (loginUid != null && !uids.contains(loginUid)) {
            throw new AuthenticationException("Not authorized to use UID: " + loginUid);
        }
        if (loginGid != null && !gids.contains(loginGid)) {
            throw new AuthenticationException("Not authorized to use GID: " + loginGid);
        }

        /* Pick one of the UIDs to use. We use the following ordered
         * rules to pick the correct one:
         *
         * - if loginUid was provided, then use that one;
         *
         * - if loginName was provided, then use the one that
         *   corresponds to that;
         *
         * - if a primary group name is provided, then use the one
         *   that corresponds to that;
         */
        long uid;
        if (loginUid != null) {
            uid = loginUid;
        } else if (loginName != null) {
            uid = getUniqueUidFor(loginName);
            authorizedPrincipals.add(new UserNamePrincipal(loginName));
        } else if (primaryGroup != null) {
            uid = getUniqueUidFor(primaryGroup);
            authorizedPrincipals.add(new UserNamePrincipal(primaryGroup));
        } else {
            throw new AuthenticationException("No unique UID found");
        }
        authorizedPrincipals.add(new UidPrincipal(uid));

        /* Pick one of the GIDs as the primary one. We use the
         * following ordered rules to pick the correct one:
         *
         * - if loginGid was provided, then use that one;
         *
         * - if loginName was provided, then use the one that
         *   corresponds to that;
         *
         * - if a primary group name is provided, then use the one
         *   that corresponds to that;
         */
        long primaryGid;
        if (loginGid != null) {
            primaryGid = loginGid;
        } else if (loginName != null) {
            primaryGid = getUniquePrimaryGidFor(loginName);
        } else if (primaryGroup != null) {
            primaryGid = getUniquePrimaryGidFor(primaryGroup);
        } else {
            throw new AuthenticationException("No unique UID found");
        }
        authorizedPrincipals.add(new GidPrincipal(primaryGid, true));

        /* Add remaining gids.
         */
        for (long gid: gids) {
            if (gid != primaryGid) {
                authorizedPrincipals.add(new GidPrincipal(gid, false));
            }
        }
    }

    /**
     * Reverse mapping is not possible for VOMS, because mapping is
     * surjective and therefore the inverse is not uniquely defined.
     */
    @Override
    public void reverseMap(SessionID sID, Principal sourcePrincipal,
            Set<Principal> principals) throws AuthenticationException
    {
        // TODO
    }

    @Override
    public void session(SessionID sID,
                        Set<Principal> authorizedPrincipals,
                        Set<SessionAttribute> attrib)
        throws AuthenticationException
    {
        Principal principal =
            find(authorizedPrincipals, instanceOf(UserNamePrincipal.class), null);
        if (principal != null) {
            Collection<UserAuthzInformation> mappings =
                _map.getValuesForPredicatesMatching(principal.getName());
            for (UserAuthzInformation mapping: mappings) {
                attrib.add(new HomeDirectory(mapping.getHome()));
                attrib.add(new RootDirectory(mapping.getRoot()));
                attrib.add(new ReadOnly(mapping.isReadOnly()));
            }
        }
    }
}
