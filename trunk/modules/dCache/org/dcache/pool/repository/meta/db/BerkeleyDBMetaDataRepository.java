package org.dcache.pool.repository.meta.db;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;

import com.sleepycat.je.DatabaseException;
import com.sleepycat.collections.StoredMap;

import org.dcache.pool.repository.DataFileRepository;
import org.dcache.pool.repository.MetaDataRepository;
import org.dcache.pool.repository.EventType;
import org.dcache.pool.repository.EventProcessor;
import org.dcache.pool.repository.DuplicateEntryException;
import diskCacheV111.repository.CacheRepositoryEntry;
import diskCacheV111.util.event.CacheRepositoryEvent;
import diskCacheV111.util.PnfsId;
import diskCacheV111.util.CacheException;

/**
 * BerkeleyDB based MetaDataRepository implementation. 
 *
 * The database is stored in a subdirectory of the pool directory
 * called 'meta'. 
 *
 * The cache repository entries generated by this repository fetch
 * storage info from the database on demand and caches them using a
 * SoftReference.
 *  
 * Warning: Currently not thread safe! This is acceptable as long as
 * it is only used by CacheRepositoryV4, since that class takes care
 * of the synchronisation.
 */
public class BerkeleyDBMetaDataRepository 
    implements MetaDataRepository, EventProcessor
{
    private static final String DIRECTORY_NAME = "meta";

    /**
     * The data repository for which we hold the meta data.
     */
    private final DataFileRepository _dataRepository;

    /**
     * Event processor to which to deliver events from the entries.
     */
    private final EventProcessor _eventProcessor;

    /**
     * The BerkeleyDB database to use.
     */
    private final MetaDataRepositoryDatabase _database;

    /**
     * The BerkeleyDB database to use.
     */
    private final MetaDataRepositoryViews _views;

    /**
     * Directory containing the database.
     */
    private final File _dir;

    /**
     * Opens a BerkeleyDB based meta data repository. If the database
     * does not exist yet, then it is created. If the 'meta' directory
     * does not exist, it is created.
     */ 
    public BerkeleyDBMetaDataRepository(DataFileRepository dataRepository,
                                        EventProcessor eventProcessor,
                                        File directory)
        throws FileNotFoundException, DatabaseException
    {
        _dataRepository = dataRepository;
        _eventProcessor = eventProcessor;
        _dir = new File(directory, DIRECTORY_NAME);
        
        if (!_dir.exists()) {
            _dir.mkdir();
        }

        _database = new MetaDataRepositoryDatabase(_dir);
        _views = new MetaDataRepositoryViews(_database);
    }

    public CacheRepositoryEntry get(PnfsId id) 
    {
        return CacheRepositoryEntryImpl.load(this, id);
    }

    /**
     * TODO: The entry is not persistent yet!
     */
    public CacheRepositoryEntry create(PnfsId id)
        throws DuplicateEntryException
    {
        /* CacheRepositoryEntryImpl.load silently drops incomplete
         * entries. To conform to the contract of the
         * MetaDataRepository interface, we need to check whether both
         * records are present in the database.
         */
        if (get(id) != null) {
            throw new DuplicateEntryException(id);
        }
        return new CacheRepositoryEntryImpl(this, id);
    }

    /**
     * TODO: The entry is not persistent yet!
     */
    public CacheRepositoryEntry create(CacheRepositoryEntry entry)
        throws DuplicateEntryException, CacheException
    {
        /* CacheRepositoryEntryImpl.load silently drops incomplete
         * entries. To conform to the contract of the
         * MetaDataRepository interface, we need to check whether both
         * records are present in the database.
         */
        PnfsId id = entry.getPnfsId();
        if (get(id) != null) {
            throw new DuplicateEntryException(id);
        }
        return new CacheRepositoryEntryImpl(this, entry);
    }
    
    public void remove(PnfsId id)
    {
        _views.getStorageInfoMap().remove(id.toString());
        _views.getStateMap().remove(id.toString());
    }

    public boolean isOk()
    {
       try {
           File tmp = new File(_dir, ".repository_is_ok");
	   tmp.delete();
	   tmp.deleteOnExit();

	   if (!tmp.createNewFile())
               return false;

	   if (!tmp.exists())
               return false;

	   return true;
	} catch (IOException e) {
	   return false;
	}
    }

    /**
     * Requests a data file from the CacheRepository. Used by the
     * entries to obtain a data file.
     */
    File getDataFile(PnfsId id)
    {
        return _dataRepository.get(id);
    }

    /**
     * Forwards an event to the CacheRepository. Used by the entries
     * for event notification.
     */
    public void processEvent(EventType type, CacheRepositoryEvent event)
    {
        _eventProcessor.processEvent(type, event);
    }

    /**
     * Returns a database backed map of all StorageInfo objects.
     */
    StoredMap getStorageInfoMap()
    {
        return _views.getStorageInfoMap();
    }

    /**
     * Returns a database backed map of all state objects.
     */
    StoredMap getStateMap()
    {
        return _views.getStateMap();
    }

    /**
     * Returns the path 
     */
    public String toString()
    {
        return _dir.toString();
    }
}
